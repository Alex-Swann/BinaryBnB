/**
 * Populate returned query results
 */

/**
 * Module dependencies
 */

var r           = require('rethinkdb');
var extend      = require('seed-extend');
var find        = require('../util/find');
var parallel    = require('../util/parallel');
var inflection  = require('inflection');

/**
 * Helpers
 */

/**
 * Build population options from schema and query options
 */

function buildOptions(params, schema) {
  return [].concat(params).map(function(item) {
    var options = extend({ 
      field: item.field || item,
      ref: null,
      refField: 'id', 
      destination: item.field || item, 
      single: true,
      populate: item.populate,
      query: null,
      options: {}
    }, schema.fields[item.field || item] || {}, item);
    return options;
  });
}

/**
 * Return an array of unique primitives (wont work on objects, arrays etc.)
 *
 * @param {Array} arr
 * @return {Array} unique
 */

function unique(arr) {
  var obj = {};
  return arr.filter(function(item) {
    if (!obj[item]) {
      obj[item] = true;
      return true;
    }
  });
}

/**
 * Populate a rethink model using params from query and schema
 *
 * @param {Rethink} rethink
 * @param {Object} params, check after-hook params
 *   @param {Object} query
 *   @param {Object} options
 *   @param {Array} results
 * @param {Object} schema, rethink-built schema
 * @param {Function} done(err)
 */

function populate(rethink, params, schema, done) {
  if (!params.options.populate) {
    return done();
  }
  
  params.indexes = params.indexes || {};
  
  var stack = buildOptions(params.options.populate, schema); // [articleOptions, userOptions, commentsOptions]
  
  parallel(stack.map(function(options) {
    return function(cb) {
      var model = rethink.model(options.ref);
      var query = {};
      
      var ids = unique([].concat(params.results).map(function(result) {
        return result[options.field]; // get all `article` fields from references
      }));
      
      model._adapter.populate(model._tableName, ids, query, options, function(err, results) {
        
        // push ids to indexes
        params.indexes[model._tableName] = 
          unique((params.indexes[model._tableName] || [])
          .concat(results.map(function(res) { return res.id; })));
      
        if (options.single) {
          params.results.forEach(function(item) {
            item[options.destination] = find(results, options.refField, item[options.field]) 
              || item[options.destination];
          });
        } else {
          params.results.forEach(function(item) {
            item[options.destination] = results.filter(function(result) {
              return result[options.refField] === item[options.field];
            });
          });
        }
    
        // now check if options has population, and run populate on results
        if (options.populate) {
          populate(rethink, { 
            options: { populate: options.populate }, 
            results: results, 
            indexes: params.indexes
          }, model.schema, cb);
        } else {
          cb();
        }
        
      });
    }
  }), done);
}

/**
 * Install helpers
 */

function installHelpers(target) {
  
  // schema.hasOne('user'); 
  // shorthand for { field: 'user', ref: 'User', refField: 'id', destination: 'user', single: true }
  function hasOne(relation) {
    var name      = inflection.singularize(relation.toLowerCase());
    var modelName = inflection.camelize(relation.toLowerCase()); 
  
    var field = this._fields[name] = {
      type: target.types.string(), 
      index: true,
      field: name,
      ref: modelName,
      refFeild: 'id',
      destination: name,
      single: true
    };
  
    return this;
  }
  
  // schema.hasMany('comments', { refField: 'reference' });
  // shorthand for { field: 'id', ref: 'Comment', refField: 'reference', destination: 'comments', single: false }
  function hasMany(relation, options) {
    var name      = inflection.pluralize(relation.toLowerCase());
    var modelName = inflection.camelize(inflection.singularize(relation.toLowerCase())); 
    options = options || {};
    
    var field = this._fields[name] = {
      field: 'id',
      ref: modelName,
      refField: options.refField || 'id',
      destination: name,
      single: false,
      virtual: true
    }
    
    return this;
  } 
  
  target.hasOne = hasOne;
  target.hasMany = hasMany;
}

/**
 * Expose Rethink plugin
 */

exports = module.exports = function(rethink, options) {
  installHelpers(rethink.Schema.prototype);
  rethink.before('buildSchema', function(schema) {
    schema.after('query', function(params, done) {
      populate(rethink, params, params.schema, done);
    });
  });
}

/**
 * Expose schema plugin
 */

exports.populate = function(schema, options) {
  installHelpers(schema);
  schema.after('query', function(params, done) {
    populate(rethink, params, params.schema, done);
  });
}
/**
 * Create table, update indexes, and wait until all done
 */

/**
 * Module dependencies
 */

var r     = require('rethinkdb');
var Queue = require('seed-queue');
var log   = require('debug')('rethink:table');
var each  = require('./../../util/each');

/**
 * Helpers
 */

function contains(arr, el) {
  return arr.indexOf(el) !== -1;
}

/**
 * Diff db indexes and schema indexes
 *
 * @param {Object} schemaIndexes
 *   @param {Boolean||Function||Object} index
 * @param {Array} dnIndexes
 * @return {Object} diff
 *   @param {Array} create
 *     @param {String} name
 *     @param {Object} options
 *     @param {Function} expression
 *   @param {Array} remove
 *     @param {String} name
 */

function diffIndexes(schemaIndexes, dbIndexes) {
  var diff = {
    create: [],
    remove: []
  }
  
  var names = Object.keys(schemaIndexes);
  
  each(schemaIndexes, function(index, name) {
    if (!contains(dbIndexes, name)) {
      var idx = { name: name };
      if (typeof index === 'Function') {
        idx.expression = index;
      } else if (typeof index === 'Object') {
        idx.expression = index.expression;
        idx.options = {
          geo: index.geo,
          multi: index.multi
        }
      }
      diff.create.push(idx);
    }
  });
  
  each(dbIndexes, function(name) {
    if (!contains(names, name)) {
      diff.remove.push(name);
    }
  });
  
  return diff;
}

/**
 * Initialize
 *
 * @param {Object} schema (after it's being built)
 * @param {Function} exec(fn(connection)), rethink db connection
 */

function Table(name, schema, exec) {
  if (!(this instanceof Table)) {
    return new Table(name, schema, exec);
  }
  
  this._name = name;
  this._schema = schema;
  this._exec = exec;
  this._indexes = null; // []
  
  this._createTable();
  this._fetchIndexes();
  this._updateIndexes();
  this._wait();
}

Table.prototype._createTable = function() {
  this._exec(function(connection, done) {
    r.tableCreate(this._name).run(connection, function(err) {
      if (err) log(err.message);
      // ignore errors on table creation
      // or better match error to 'table already exists'
      done();
    });
  }.bind(this));
}

Table.prototype._fetchIndexes = function() {
  this._exec(function(connection, done) {
    r.table(this._name).indexList().run(connection, function(err, indexes) {
      if (err) throw err;
      this._indexes = indexes;
      done();
    }.bind(this));
  }.bind(this));
}

Table.prototype._updateIndexes = function() {
  this._exec(function(connection, done) {
    var diff = diffIndexes(this._schema.indexes, this._indexes);
    
    diff.create.forEach(function(index) {
      this._exec(function(connection, done) {
        r.table(this._name).indexCreate(
          index.name, 
          index.expression, 
          index.options
        ).run(connection, function(err) {
          // ignore errors on index creation
          // or better match error to 'index already exists'
          done();
        });
      }.bind(this));
    }.bind(this));
    
    diff.remove.forEach(function(index) {
      this._exec(function(connection, done) {
        r.table(this._name).indexDrop(index).run(connection, function(err) {
          if (err) throw err;
          done();
        });
      });
    }.bind(this));
    
    done();
  }.bind(this));
}

Table.prototype._wait = function() {
  this._exec(function(connection, done) {
    r.table(this._name).indexWait().run(connection, function(err, status) {
      if (err) throw err;
      done();
    });
  }.bind(this));
}

/**
 * Expose
 */

exports = module.exports = Table;
/**
 * Rethink model
 */

/**
 * Module dependencies
 */

var inflection  = require('inflection');
var extend      = require('seed-extend');
var Queue       = require('seed-queue');
var log         = require('debug')('rethink:model');
var Types       = require('./types');

/**
 * Constructor
 * 
 * @param {String} name
 * @param {Schema} schema
 * @param {Function} exec(fn(connection, fn))
 * @param {Rethink} rethink
 */

function Model(name, schema, adapter) {
  if (!(this instanceof Model)) {
    return new Model(name, schema, adapter);
  }
  
  // e.g. `Person`
  this._name = name; 
  
  // e.g. `people`
  this._tableName = inflection.pluralize(name.toLowerCase());
  
  // queue/execute on current rethinkdb connection
  this._adapter = adapter; 
  
  // assemble schema
  this.schema = schema._build();
  
  // default paramaters
  this._defaultParams = {};
    
  // initialize table, build indexes etc.
  this._adapter.ensureTable(this._tableName, this.schema);
  
  // static methods, eg. Person.save() and Person.byAddress()
  extend(this, this.schema.statics);
}

/**
 * Get defaults
 *
 * @param {Object} object
 * @param {Function} cb(err, object)
 *
 * @api private
 */

Model.prototype._getDefaults = function(object, cb) {
  var self = this;
  var empty = Object
    .keys(this.schema.defaults)
    .filter(function(key) { return typeof object[key] === void 0; });
  
  var queue = new Queue({});
  
  empty.forEach(function(key) {
    queue.add(function(ctx, next) {
      var val = self.schema.defaults[key];
      if (typeof val !== 'function') {
        ctx[key] = JSON.parse(JSON.stringify(val)); // for [] and {}
        next();
        return;
      } 
      if (val.length === 1) {
        ctx[key] = val(object);
        next();
        return;
      } 
      val(object, function(err, value) {
        if (err) return next(err);
        ctx[key] = value;
        next();
      });
    });
  });
  
  queue.end(cb);
}

/**
 * Validate an object
 *
 * @param {Object} object
 * @param {Function} cb(err, object)
 *
 * @api private
 */

Model.prototype._validate = function(object, cb) {
  var self = this;
  self._runHooks('before', 'validate', object, function(err, object) {
    if (err) return cb(err);
    Types.validate(object, self.schema.validation, function(err, object) {
      if (err) return cb(err);
      self._runHooks('after', 'validate', object, cb);
    });
  });  
}

/**
 * Run hooks before/after an action
 *
 * @param {String} order, 'before' or 'after'
 * @param {String} action, eg. 'validate', 'save', etc.
 * @param {Object} object, context
 * @param {Function} cb(err, object)
 *
 * @api private
 */

Model.prototype._runHooks = function(order, action, object, cb) {
  var queue = new Queue(object);
  var hooks = this.schema[order + 'Hooks'][action];
  if (!hooks.length) return cb(null, object);
  hooks.forEach(function(hook) {
    queue.add(hook);
  });
  queue.end(cb);
}

/** 
 * Create a new record
 *
 * @param {Object} record
 * @param {Function} callback(err, result)
 */

Model.prototype.create = function(object, cb) {
  var self = this;
  
  Queue({ 
    object: extend({}, this.schema.defaults, object)
  })
  .add(function(ctx, next) {
    self._getDefaults(ctx.object, function(err, defaults) {
      if (err) return next(err);
      extend(ctx.object, defaults);
      next();
    });
  })
  .add(function(ctx, next) {
    self._validate(ctx.object, function(err, object) {
      if (err) return next(err);
      ctx.object = object;
      next();
    });
  })
  .add(function(ctx, next) {
    self._runHooks('before', 'create', ctx.object, function(err, object) {
      if (err) return next(err);
      ctx.object = object;
      next();
    });
  })
  .add(function(ctx, next) {
    self._runHooks('before', 'save', ctx.object, function(err, object) {
      if (err) return next(err);
      ctx.object = object;
      next();
    });
  })
  .add(function(ctx, next) {
    self._adapter.create(self._tableName, ctx.object, function(err, result) {
      if (err) return next(err);
      ctx.object = result;      
      next();
    });
  })
  .add(function(ctx, next) {
    // after hooks        
    self.schema.afterHooks.save.forEach(function(hook) {
      hook(ctx.object);
    });

    // after hooks        
    self.schema.afterHooks.create.forEach(function(hook) {
      hook(ctx.object);
    });
    
    next();
  })
  .end(function(err, ctx) {
    if (err) return cb(err);
    cb(null, ctx.object);
  });
}

/** 
 * Update a record
 *
 * @param {Object} record
 * @param {Function} callback(err, result)
 */

Model.prototype.update = function(object, cb) {
  var self = this;
  
  Queue({ 
    object: extend({}, this.schema.defaults, object)
  })
  .add(function(ctx, next) {
    self._validate(ctx.object, function(err, object) {
      if (err) return next(err);
      ctx.object = object;
      next();
    });
  })
  .add(function(ctx, next) {
    self._runHooks('before', 'update', ctx.object, function(err, object) {
      if (err) return next(err);
      ctx.object = object;
      next();
    });
  })
  .add(function(ctx, next) {
    self._runHooks('before', 'save', ctx.object, function(err, object) {
      if (err) return next(err);
      ctx.object = object;
      next();
    });
  })
  .add(function(ctx, next) {
    self._adapter.update(self._tableName, ctx.object, function(err, result) {
      if (err) return next(err);
      ctx.object = result;      
      next();
    });
  })
  .add(function(ctx, next) {
    // after hooks        
    self.schema.afterHooks.save.forEach(function(hook) {
      hook(ctx.object);
    });

    // after hooks        
    self.schema.afterHooks.update.forEach(function(hook) {
      hook(ctx.object);
    });
    
    next();
  })
  .end(function(err, ctx) {
    if (err) return cb(err);
    cb(null, ctx.object);
  });
}

/** 
 * Remove a record
 *
 * @param {String} id
 * @param {Function} callback(err, result)
 */

Model.prototype.remove = function(id, cb) {
  var self = this;
  Queue({ 
    id: id 
  })
  .add(function(ctx, next) {
    self._runHooks('before', 'remove', ctx.id, function(err, id) {
      if (err) return next(err);
      ctx.id = id;
      next();
    });
  })
  .add(function(ctx, next) {
    self._adapter.remove(self._tableName, ctx.id, function(err) {
      if (err) return next(err);
      next();
    });
  })
  .add(function(ctx, next) {
    self.schema.afterHooks.remove.forEach(function(hook) {
      hook(ctx.id);
    });
    next();
  })
  .end(function(err, ctx) {
    if (err) return cb(err);
    cb(null, ctx.id);
  });
}

/**
 * Find records
 *
 * @param {Object} query
 * @param {Object} options, optional
 *   @param {Number} limit
 *   @param {Number} offset
 *   @param {Object} order, e.g { index: 'a' }
 *   @param {Boolean} feed
 *   @param {String|Function} order
 * @param {Function} cb(err, results)
 */

Model.prototype.find = function(query, options, cb) {
  var self = this;
  
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }
  
  Queue({ 
    query: query, 
    options: options, 
    schema: this.schema 
  })
  .add(function(ctx, next) {
    self._runHooks('before', 'query', ctx, function(err) {
      if (err) return next(err);
      next();
    });
  })
  .add(function(ctx, next) {
    self._adapter.find(self._tableName, ctx.query, ctx.options, function(err, results) {
      if (err) return next(err);
      ctx.results = results;
      next();
    });
  })
  .add(function(ctx, next) {
    self._runHooks('after', 'query', ctx, function(err) {
      if (err) return next(err);
      next();
    });
  })
  .end(function(err, ctx) {
    if (err) return cb(err);
    cb(null, ctx.results);
  });  
}

/**
 * Find one record
 *
 * @param {Object} query
 * @param {Object} options, optional
 *   @param {Number} limit (will be forced to 1)
 *   @param {Number} offset
 *   @param {String|Function} order
 *   @param {Boolean} feed
 * @param {Function} cb(err, result)
 */

Model.prototype.findOne = function(query, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {}
  }
  
  options.limit = 1;
  
  this.find(query, options, function(err, results) {
    if (err) return cb(err);
    cb(null, results[0]);
  });
}

/**
 * Expose
 */

exports = module.exports = Model;